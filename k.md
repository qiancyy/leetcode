# 贪心算法   

- 在选择的时候是具有倾向的，选择导致目前状况最好的情况，如在T860中，我们更需要5元想比较10元来说，所以，在面对找零15元时，优先使用10+5的组合,然后在考虑5+5+5的情况。在合并区间类题中，我们根据右区间从小到大排序，是因为右区间越小，会留有更多的空间使得另外的range中的左区间和它没有重合。（前端紧凑或者说是吝啬）

- 有意思的T135:　步步为营，既然说rank大于左右，则执行两遍贪心的原则，从左扫描，得到一个贪心结果，从右向左扫描，得到对之前结果的修正．



## 区间问题

许多区间问题形如`pair<int,int>`可以通过贪心求解,也往往可以通过先 sort 将 first 排序后再考虑 second

# 双指针

- 有序数组（左右双指针向中间逼近（事实上是一种穷举策略））
- **滑动窗口** （优美的算法）
  滑动窗口**本质**上来源于**单调性**，应用在这些题目里可以认为，随着左端点位置的增加，其最优决策的右端点位置单调不减  
  T76/T340:（左右指针限定窗口，右指针移动，左指针保持不变，当窗口中出现的内容符合条件，左指针移动，缩小窗口的大小，以达到窗口大小的最优化，当窗口中内容不符合条件时停止，右指针继续右移上述操作，以期望窗口中再次出现符合条件的情况）

# 二分查找

- 有问题可以抽象为数学形式：f(X1)*f(X2)<0 且f(X)在[x1,x2]单调，必有离散解f(X0)=0，在此情况下，通过二分，可以在O(nlgn)中缩小[x1,x2]解的范围

# DFS

- T417好难啊 qaq   （T542）

  ## 回溯
- dfs基础上在dfs之前，记录需要修改的状态，在dfs之后，用记录值恢复修改的状态，继续下一轮的遍历。
- T46 全排列 用swap去解很妙

# BFS
- **处理最短路径**

# Dynamic Programming
### 一些摘录的思想：

1. 贪心理解成dp基于某种性质优化
2. 待补充：）

## DP 问题类型：

### 1. 股票买卖：

[link](https://leetcode-cn.com/circle/article/qiAgHn/)

### 1.1 summary：
第i天结束时，最多进行k次交易的情况下可以获得的最大收益的关联因素有三：一是i，二是k，三是当前手中是否持有股票，因此有转移函数：

T[i][k][0] = max(T[i - 1\][k\][0], T[i - 1\][k\][1] + prices[i])

T[i][k][1] = max(T[i - 1\][k\][1], T[i - 1\][k - 1\][0] - prices[i])

最后一天的最高收益为T[n - 1\][k\][0]

### 2. 子序列问题：

经典问题1： T300.最长递增子序列：
dp[i]代表前i个数中，如果选择第i个数，递增元素的个数。需要两个for是因为显然子序列是离散的，我们要选定当前的元素的值和之前的进行比较，由于dp表示的是选定，所以当我们后续的元素大于这个值的时候，需要加上自己本身，由此dp[j]+1。另：引出线段树的解法，希望能看懂。
	

	for i 1->nums.size()
		for j 0->i
			if(nums[i]>nums[j]) dp[i]=max(dp[i],dp[j]+1)

问题1.1 T646.最长数对链:
按vector[0]元素sort,然后重复T300解法，为什么想到需要sort，因为两端都不固定，例如输入为[[3,4\][1,2]],4>1,似乎不能作为链，如果按照首个元素排序，那么vector a[0]>vector b[1]将作为唯一判断是否可以选择的标准。 另：这道题用greedy更为合适，类似活动安排。

问题1.2 T491.递增子序列
同样的双重for循环的思想，同样的大小判断，判断的内部，记录当前元素，扩充之前的元素的数组，换言之，这里的dp是数组，记录了到这个元素为止的子序列，我们只需要将这些子序列取出，加上当前的元素，形成新的子序列，与此同时，加入自身。值得注意的是，这样操作无法去重，需要借助set,对于此题来说，效率不高。

问题1.3 T376.摆动序列
预处理：对于后元素-前元素得到新的数组，注意，当相邻为重复元素时，我们需要删除一个重复元素，然后再求差值。 现在我们得到的是一个差值的序列，我们要做的是选出一组序列满足相邻元素符号不同。由于取的是最大的序列，而我们这里得到的差值是最小单元，所以不存在问题。应用双重for循环，修改判断条件即可。更好的思路：看成股票问题，股票问题一个sell，一个purchase两个状态，现在差值为正，差值为负两个状态，遍历状态转移；另：贪心解法

### 2.1 summary：
对于子序列来说，上述的代码其实是一个通解，或者说倾向于一个暴力解法，因为本质上还是遍历了所有的可能性，作为通解，效率往往不是很高，所以有很多子序列的问题可以通过贪心更快去解决，但这种方法不失为一个解决方案。

### 3. 背包问题：
参考[https://zhuanlan.zhihu.com/p/93857890]
### 3.1 summary：
0-1背包：dp[i\][j] = max(dp[i−1\][j], dp[i−1\][j−w[i]]+v[i])

完全背包：在使用之后还能使用当前的物品下标i在选择继续使用的时候维持不变：dp[i\][j] = max(dp[i−1\][j], dp[i\][j−w[i]]+v[i])

多重背包：遍历选0件物品，选1件物品，直到min(V/space[i],nums[i])得到单个dp[i\][j]的最大值，整个物品的限制基于0-1背包和完全背包中间
		
	dp[0,...,W] = 0
	for i = 1,...,N
		for j = W[i],...,w 
	    	for k = [0, 1,..., min(n[i], j/w[i])]
	        	dp[i][j] = max(dp[i-1][j], dp[i-1][j−k*w[i]]+k*v[i])

多重背包退化为0-1背包：k只能取0/1 回归到0-1背包状态转移。

多重背包进化为完全背包：k的取值变为[0,j/w[i]],对比完全背包的式子，我们只需要证明dp[i\][j-w[i]]+v[i]=max(dp[i-1\][j-k*w[i]\]+k*w[i],k属于[1,j/w[i]],这是显然的，由完全背包转移方程可知，dp[i\][j-w[i]]=max(dp[i-1\][j-w[i]],dp[i\][j-2*w[i]]+2*w[i],我们发现每次都会分离出一个前面需要证明的等式右边项，得证。由此我们直到，对于min(V/space[i],nums[i])=V/space[i]的情况，不受限制，即为完全背包。

三类应用题：

1. 恰好装满：因为任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。如果有恰好装满的限制，那只应该将dp[0,...,N\][0]初始为0，其它dp值均初始化为-inf

2. 求类型总数：max(dp1,dp2)->sum(dp1,dp2)

3. 求最优方案：回溯

# 分治算法
自上而下的分治可以和 memoization 结合，避免重复遍历相同的子问题。如果方便推
导，也可以换用自下而上的动态规划方法求解

好难啊这我不太会

#  随机采样

- Fisher-Yates洗牌     for(int i=num.size()-1;i>=0;i--){
swap(shuffled[i],shuffled[rand()%(i+1)])}
- 水库采样：遍历链表，在遍历到第m个节点时候，有1/m的概率选择这个节点覆盖掉之前的节点选择。
#  位运算
- 基本性质:1.x^x=0 2. x^1=~x 3.x^0=x  4.n&(n-1)可以去除n的位级表示中最低的那位；n&(-n)可以得到n的最低的那位
- T318 提供了一个很好的思路，对比两个字符串是否相同的问题，可以将二十六个字符对应二十六位，对位进行&操作
- T371 用位运算来表示 +
看到的帖子：[link](https://www.cnblogs.com/kubidemanong/p/10880482.html)

# 常用数据结构：(练习没做)

关于hash：
寻找的时候有count和find：在map中查找key 为 k的元素，返回指向它的迭代器。若k不存在，返回 map::end.

返回值是一个迭代器，成功返回迭代器指向要查找的元素，失败返回的迭代器指向end。

count()
统计map中 key为k的元素的个数，对于map，返回值不是1(存在)，就是0(不存在)

## 	负负得正的思想：
​		T448：将遍历到的数组元素作为访问元素的下标（通过abs取正数）然后对该访问元素取反，最终遍历数组中不是负数的元素的下标即为所求
​		T232 stack(first in second out)/queue(first in first out) 
利用这个性质通过两个stack的颠倒得到queue

## 	保持维护结构思想：
​		T155： 维护一个最小栈或者说一个单调栈min_stack中代表之前输入的最小值，所以在push时只有输入的比栈顶小，min_stack 才能push，相似的T739:从后向前遍历，维护的是一个递增的栈，因为对于问题来说，温度越大，越靠前，越可能作为那个最小的更暖的日期

## 	priority_queue
​		priority_queue<type,vector<type>,class>pq;

​		自定义比较写法：定于struct类，类中重写operator()(type a,type b){}
​		典型例题：T34



# 字符串

待补充：）

# 链表

待补充：）

## 	应该掌握：
如何用递归和非递归表示
# 树：（练习没做）
数的构建:T1110,；
遍历:T437,T105(不会做)；
BST实现；

## 字典树：（找字符串前缀）
T208:每个节点包含有26个节点类指针和一个bool判断当前节点是否是单词的结束。

#  图
## 二分图：
T785: 染色法，是一种广度优先搜索。如果可以用两种颜色对图中的节点进行着
色，并且保证相邻的节点颜色不同，那么图为二分

## 拓扑排序（有向无环图）：
1.分离所有入度为0的节点，

2.若节点入度为0，则作为处理的节点，将该节点指向的节点的入度--

3.重复操作2，如果最后还有顶点为输出，则说明有环。

T207/T210

#  复杂数据结构：
## 并查集：
并查集（union-find, 或 disjoint set）可以动态地连通两个点，并且可以非常快速地判断两个点是否连通
[https://zhuanlan.zhihu.com/p/93647900/]
### Kruskal's algorithm
T1135： 配合并查集 [相关解释](https://blog.csdn.net/hhygcy/article/details/4061918)

## 关于迭代器

待补充：）

## 一些补充：

1. three-way partition
   T75:处理两端，三个变量记录left，right，以及一个遍历的i，需要注意是2换去后来 换来的数值不一定是0可以跳过的 所以curr此时不能+1
   T324：利用 three-way partition性质，我**只在乎左边的元素中间元素右边元素的顺序关系，而不在乎左边或是右边的内部的排序**，这道题是左边大-中间-右边小的结构，与T75正好相反（T75的mid可以视为1），通过巧妙的映射关系，将左边的元素映射到奇数下标的数组中，从而形成震荡.

   









# 一些STL：
1. 字符转数字：stoi()的参数是const string*;atoi()的参数是 const char* ; 数字转字符：to_string  

2. 数组去重set<int> st(vec.begin(), vec.end());
vec.assign(st.begin(), st.end());

3. 大顶堆&小顶堆 默认是less 的大顶堆
`
priority_queue<int, vector<int>, less<int>>s;//less表示按照递减(从大到小)的顺序插入元素`
`
priority_queue<int, vector<int>, greater<int>>s;//greater表示按照递增（从小到大）的顺序插入元素
`
4. set&unordered_set || map&unordered_map

	set基于红黑树实现，红黑树具有自动排序的功能，因此map内部所有的数据，在任何时候，都是有序的。

	unordered_set基于哈希表，数据插入和查找的时间复杂度很低，几乎是常数时间，而代价是消耗比较多的内存，无自动排序功能
5. multiset 允许重复，但是erase清除所有的元素,如果要清除单个，通过find寻找pos,然后再清除。 
6. 二分查找：lower_bound(迭代器first，迭代器end,val)、在指定区域内查找不小于目标值的第一个元素;upper_bound()同理
7. nth_element(std::begin(), std::begin() + count, std::end()) 第四个参数默认为less<>() 表示在第 n 个元素之前的元素都小于第 n 个元素，而且它后面的每个元素都会比它大，greater<>()产生结果相反 

